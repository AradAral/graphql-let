import generator from '@babel/generator';
import logUpdate from 'log-update';
import { loader } from 'webpack';
import { relative as pathRelative } from 'path';
import { modifyLiteralCalls, visitLiteralCalls } from './babel';
import createExecContext from './lib/exec-context';
import loadConfig from './lib/config';
import { parserOption } from './lib/literals/fns';
import { processLiteralsWithDtsGenerate } from './lib/literals/literals';
import memoize from './lib/memoize';
import { PRINT_PREFIX } from './lib/print';
import { LiteralCodegenContext } from './lib/types';
import * as t from '@babel/types';
import { parse } from '@babel/parser';
import traverse, { NodePath } from '@babel/traverse';

const processGraphQLLetLoader = memoize(
  async (
    resourceFullPath: string,
    resourceContent: string | Buffer,
    addDependency: (path: string) => void,
    cwd: string,
  ): Promise<string | Buffer> => {
    const [config, configHash] = await loadConfig(cwd);
    const execContext = createExecContext(cwd, config, configHash);

    // Do nothing when it's a file generated by graphql-let
    if (resourceFullPath.startsWith(execContext.cacheFullDir)) {
      return resourceContent;
    }

    const resourceRelPath = pathRelative(cwd, resourceFullPath);

    const ast = parse(String(resourceContent), parserOption);

    const content: string = await new Promise((resolve) => {
      traverse(ast, {
        Program(programPath: NodePath<t.Program>) {
          // TODO: refactor
          const importName = 'graphql-let';
          const onlyMatchImportSuffix = false;

          const visitLiteralCallResults = visitLiteralCalls(
            programPath,
            importName,
            onlyMatchImportSuffix,
          );
          const {
            hasError,
            literalCallExpressionPaths,
          } = visitLiteralCallResults;

          if (hasError || !literalCallExpressionPaths.length) return;

          const gqlContents = literalCallExpressionPaths.map(
            ([, value]) => value,
          );
          processLiteralsWithDtsGenerate(
            execContext,
            resourceRelPath,
            gqlContents,
          ).then((literalCodegenContext: LiteralCodegenContext[]) => {
            modifyLiteralCalls(
              programPath,
              resourceFullPath,
              visitLiteralCallResults,
              literalCodegenContext,
            );
            const { code } = generator(ast);
            resolve(code);
          });
        },
      });
    });
    if (!content) throw Error('never');
    return content;
  },
  (gqlFullPath: string) => gqlFullPath,
);

const literalLoader: loader.Loader = function (gqlContent) {
  const callback = this.async()!;
  const { resourcePath, rootContext: cwd } = this;

  processGraphQLLetLoader(
    resourcePath,
    gqlContent,
    this.addDependency.bind(this),
    cwd,
  )
    .then((content) => {
      callback(undefined, content);
    })
    .catch((e) => {
      logUpdate.stderr(PRINT_PREFIX + e.message);
      logUpdate.stderr.done();
      callback(e);
    });
};

export default literalLoader;
